<div class="theory-block">
    <span class="stage-badge">Learning Objective</span>
    <h3>Two’s Complement Representation</h3>
    <p><b>12.1.1.4 — Represent positive and negative numbers in Two’s Complement.</b></p>

    <p>
        Modern computer systems must process both positive and negative integers. 
        While unsigned binary allows only non-negative values, real-world computation 
        requires an efficient signed representation. The universally adopted method 
        in modern processors is <b>Two’s Complement</b>.
    </p>

    <div class="interactive-box">
        <strong><i class="fas fa-microchip"></i> Why It Matters:</strong>
        Every arithmetic operation performed by the CPU’s Arithmetic Logic Unit (ALU) 
        relies on fixed-width binary registers. Two’s Complement enables subtraction 
        using addition circuitry, simplifying hardware design.
    </div>
</div>

<div class="theory-block">
    <h3>1. The Limitation of Unsigned Binary</h3>
    <p>
        In an 8-bit unsigned system, the range is determined by the formula:
        <b>2<sup>n</sup> − 1</b>.
    </p>

    <div class="table-wrapper">
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Bits</th>
                    <th>Minimum</th>
                    <th>Maximum</th>
                    <th>Range</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>8-bit Unsigned</td>
                    <td>0</td>
                    <td>255</td>
                    <td>0 → 255</td>
                </tr>
            </tbody>
        </table>
    </div>

    <p>
        There is no representation for negative values. Therefore, a new encoding system is required.
    </p>
</div>

<div class="theory-block">
    <h3>2. The Structure of Two’s Complement</h3>

    <p>
        In Two’s Complement:
    </p>
    <ul>
        <li>The <b>Most Significant Bit (MSB)</b> acts as the sign bit.</li>
        <li>0 = positive number</li>
        <li>1 = negative number</li>
        <li>Negative values are created by inverting all bits and adding 1.</li>
    </ul>

    <div class="interactive-box">
        <strong>Mathematical Range Formula:</strong><br>
        −2<sup>n−1</sup> to +2<sup>n−1</sup> − 1
    </div>

    <p>
        For an 8-bit system:
        <b>−128 to +127</b>
    </p>
</div>

<div class="theory-block">
    <h3>3. Representing Positive Numbers</h3>
    <p>
        Positive numbers are identical to unsigned representation 
        as long as the MSB remains 0.
    </p>

    <div class="interactive-box">
        Example: +18<sub>10</sub> = 00010010<sub>2</sub>
    </div>
</div>

<div class="theory-block">
    <h3>4. Representing Negative Numbers (Step-by-Step Method)</h3>

    <h4>Example: Represent −18 in 8-bit</h4>

    <div class="table-wrapper">
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>Step</th>
                    <th>Operation</th>
                    <th>Binary</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>Write +18</td>
                    <td>00010010</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>Invert bits</td>
                    <td>11101101</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>Add 1</td>
                    <td><b>11101110</b></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="interactive-box">
        Final Answer: −18 = <b>11101110<sub>2</sub></b>
    </div>
</div>

<div class="theory-block">
    <h3>5. Why Two’s Complement Works (Modular Arithmetic)</h3>

    <p>
        Two’s Complement operates under modulo 2<sup>n</sup> arithmetic.
        In an 8-bit system:
    </p>

    <div class="interactive-box">
        2<sup>8</sup> = 256<br>
        To represent −18:<br>
        256 − 18 = 238<br>
        238<sub>10</sub> = 11101110<sub>2</sub>
    </div>

    <p>
        Thus, negative numbers are stored as: <b>2<sup>n</sup> − |value|</b>.
    </p>
</div>

<div class="theory-block">
    <h3>6. Converting Back to Decimal</h3>

    <h4>Example 1: 11111111<sub>2</sub></h4>
    <p>MSB = 1 → negative</p>

    <div class="interactive-box">
        Invert → 00000000<br>
        Add 1 → 00000001 = 1<br>
        Final Answer: −1
    </div>

    <h4>Example 2: 10000000<sub>2</sub></h4>
    <div class="interactive-box">
        Invert → 01111111<br>
        Add 1 → 10000000 = 128<br>
        Final Answer: −128
    </div>
</div>

<div class="theory-block">
    <h3>7. Subtraction Using Two’s Complement</h3>

    <h4>Example: 15 − 9</h4>

    <pre style="background:#f4f4f4;padding:15px;border-radius:8px;">
  00001111
+ 11110111
-----------
1 00000110
    </pre>

    <div class="interactive-box">
        Ignore carry-out → Result: 00000110 = 6
    </div>

    <p>
        Subtraction becomes addition of a negative number. 
        No separate subtraction hardware is required.
    </p>
</div>

<div class="theory-block">
    <h3>8. Overflow Detection</h3>

    <p>
        Overflow occurs when:
    </p>

    <ul>
        <li>Two positive numbers produce a negative result.</li>
        <li>Two negative numbers produce a positive result.</li>
    </ul>

    <h4>Example: 127 + 1</h4>

    <pre style="background:#f4f4f4;padding:15px;border-radius:8px;">
  01111111
+ 00000001
-----------
  10000000
    </pre>

    <div class="interactive-box">
        Result becomes −128 → Overflow occurred.
    </div>
</div>

<div class="theory-block">
    <h3>9. Common Mistakes</h3>
    <ul>
        <li>Forgetting to add 1 after inversion.</li>
        <li>Not fixing bit-width (must remain 8-bit, 16-bit, etc.).</li>
        <li>Using carry-out as overflow indicator incorrectly.</li>
        <li>Confusing One’s Complement with Two’s Complement.</li>
        <li>Ignoring range limits.</li>
    </ul>
</div>

<div class="theory-block" style="border-left: 5px solid #27ae60;">
    <h3>10. Practice & Knowledge Check</h3>

    <div class="faq-item" onclick="this.classList.toggle('open')">
        <div class="faq-question">
            1. Convert −5 to 8-bit Two’s Complement.
        </div>
        <div class="faq-answer">
            11111011
        </div>
    </div>

    <div class="faq-item" onclick="this.classList.toggle('open')">
        <div class="faq-question">
            2. Convert 11111010₂ to decimal.
        </div>
        <div class="faq-answer">
            −6
        </div>
    </div>

    <div class="faq-item" onclick="this.classList.toggle('open')">
        <div class="faq-question">
            3. What is the range of a 6-bit Two’s Complement system?
        </div>
        <div class="faq-answer">
            −32 to +31
        </div>
    </div>
</div>

<div class="theory-block" style="border-left: 5px solid #9b59b6;">
    <h3>11. Unit Summary</h3>

    <ul>
        <li>Two’s Complement is the standard signed binary system.</li>
        <li>Range: −2<sup>n−1</sup> to +2<sup>n−1</sup> − 1.</li>
        <li>Negative numbers = invert bits + add 1.</li>
        <li>Only one representation of zero exists.</li>
        <li>Subtraction becomes addition.</li>
        <li>Overflow depends on sign analysis, not carry-out.</li>
    </ul>

    <div class="interactive-box">
        Mastering Two’s Complement is essential for understanding CPU arithmetic, 
        register limits, overflow behaviour, and low-level programming.
    </div>
</div>
